namespace ProviderImplementation

open System.IO
open System.Xml.Linq
open Microsoft.FSharp.Core.CompilerServices
open ProviderImplementation
open ProviderImplementation.ProvidedTypes
open ProviderImplementation.ProviderHelpers
open FSharp.Data.Runtime
open FSharp.Data.Runtime.BaseTypes

// ----------------------------------------------------------------------------------------------

#nowarn "10001"

[<TypeProvider>]
type public XmlProviderFromSchema(cfg:TypeProviderConfig) as this =
  inherit DisposableTypeProviderForNamespaces()

  // Generate namespace and type 'FSharp.Data.XmlProvider'
  let asm, version, replacer = AssemblyResolver.init cfg
  let ns = "FSharp.Data"
  let xmlProvTy = ProvidedTypeDefinition(asm, ns, "XmlProviderFromSchema", Some typeof<obj>)

  let buildTypes (typeName:string) (args:obj[]) =

    // Generate the required type
    let tpType = ProvidedTypeDefinition(asm, ns, typeName, Some typeof<obj>)

    let schema = args.[0] :?> string
    let elementName = args.[1] :?> string
    let elementNamespace = args.[2] :?> string
    let resolutionFolder = args.[3] :?> string
    let resource = args.[4] :?> string
    
    let parseSingle _ value = XsdParsing.parseSchema resolutionFolder value
    let parseList _ _ = failwith "unexpected call to parseList"
        
    let getSpecFromFromSchema schemaSet = 

      let inferedType = using (IO.logTime "Inference" schema) <| fun _ ->
        schemaSet 
        |> Seq.exactlyOne
        |> XsdParsing.getElement elementName elementNamespace
        |> XsdInference.inferElement

      using (IO.logTime "TypeGeneration" schema) <| fun _ ->

      let cultureStr = System.Globalization.CultureInfo.InvariantCulture.Name
      let ctx = XmlGenerationContext.Create(cultureStr, tpType, false, replacer)  
      let result = XmlTypeBuilder.generateXmlType ctx inferedType

      { GeneratedType = tpType
        RepresentationType = result.ConvertedType
        CreateFromTextReader = fun reader -> 
          result.Converter <@@ XmlElement.Create(%reader) @@>
        CreateFromTextReaderForSampleList = fun reader -> 
          result.Converter <@@ XmlElement.CreateList(%reader) @@> }

    generateType "XSD" schema false parseSingle parseList getSpecFromFromSchema 
                 version this cfg replacer "" resolutionFolder resource typeName

  // Add static parameter that specifies the API we want to get (compile-time) 
  let parameters = 
    [ ProvidedStaticParameter("Schema", typeof<string>)
      ProvidedStaticParameter("ElementName", typeof<string>)
      ProvidedStaticParameter("ElementNamespace", typeof<string>, parameterDefaultValue = "")
      ProvidedStaticParameter("ResolutionFolder", typeof<string>, parameterDefaultValue = "")
      ProvidedStaticParameter("EmbeddedResource", typeof<string>, parameterDefaultValue = "") ]

  let helpText = 
    """<summary>Typed representation of a XML file.</summary>
       <param name='Schema'>Location of a schema file or a string containing xsd.</param>
       <param name='ElementName'>Name of an element defined in the schema.</param>
       <param name='ElementNamespace'>Namespace of the element.</param>                     
       <param name='ResolutionFolder'>A directory that is used when resolving relative file references (at design time and in hosted execution).</param>
       <param name='EmbeddedResource'>When specified, the type provider first attempts to load the schema from the specified resource 
          (e.g. 'MyCompany.MyAssembly, resource_name.xsd'). This is useful when exposing types generated by the type provider.</param>"""


  do xmlProvTy.AddXmlDoc helpText
  do xmlProvTy.DefineStaticParameters(parameters, buildTypes)

  // Register the main type with F# compiler
  do this.AddNamespace(ns, [ xmlProvTy ])
